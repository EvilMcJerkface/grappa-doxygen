<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Grappa: Grappa Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grappa
   &#160;<span id="projectnumber">r3786, hash ce3e6dcdc057fcd27a8b0749c38bad7366335725</span>
   </div>
   
  </td>
  
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespace_grappa.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Grappa Namespace Reference<div class="ingroups"><a class="el" href="group___memory.html">Memory</a> &#124; <a class="el" href="group___utility.html">Utility</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>this core's base pointer  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa_1_1delegate.html">delegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa_1_1_metrics.html">Metrics</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa_1_1_shared_message_pool.html">SharedMessagePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa_1_1util.html">util</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_callback_metric.html">CallbackMetric</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metric that uses a callback to determine the value at sample time.  <a href="class_grappa_1_1_callback_metric.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_completion_event.html">CompletionEvent</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization primitive useful for waking a worker after a number of other things complete.  <a href="class_grappa_1_1_completion_event.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_counting_semaphore.html">CountingSemaphore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Counting semaphore. Maximum count is 2^15 - 1.  <a href="class_grappa_1_1_counting_semaphore.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_external_count_payload_message.html">ExternalCountPayloadMessage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For Payload messages that need to set an existing flag when message created and unset when message sent.  <a href="class_grappa_1_1_external_count_payload_message.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grappa_1_1_file.html">File</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a> file descriptor.  <a href="struct_grappa_1_1_file.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grappa_1_1_i_o_descriptor.html">IODescriptor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basically a wrapper around a POSIX "struct aiocb" with info for resuming the calling <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a> thread.  <a href="struct_grappa_1_1_i_o_descriptor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_flat_combiner.html">FlatCombiner</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class to provide full-bit semantics for arbitrary data.  <a href="class_grappa_1_1_full_empty.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_global_bag.html">GlobalBag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Global unordered queue with local insert and iteration.  <a href="class_grappa_1_1_global_bag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grappa_1_1_completion_target.html">CompletionTarget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by enroll used to indicate where to send a completion.  <a href="struct_grappa_1_1_completion_target.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_grappa_1_1_global_completion_event.html" title="GlobalCompletionEvent (GCE): Synchronization construct for determining when a global phase of asynchr...">GlobalCompletionEvent</a> (GCE): Synchronization construct for determining when a global phase of asynchronous tasks have all completed.  <a href="class_grappa_1_1_global_completion_event.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_global_counter.html">GlobalCounter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_global_hash_map.html">GlobalHashMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_global_hash_set.html">GlobalHashSet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_suspended_delegate_queue.html">SuspendedDelegateQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_global_vector.html">GlobalVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grappa_1_1_empty.html">Empty</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_grappa_1_1_empty.html" title="Empty struct, for specifying lack of either Vertex or Edge data in Graph.">Empty</a> struct, for specifying lack of either Vertex or Edge data in <a class="el" href="group___graph.html">Graph</a>.  <a href="struct_grappa_1_1_empty.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grappa_1_1_graph.html">Graph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grappa_1_1_adj_iterator.html">AdjIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_tuple_graph.html">TupleGraph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_histogram_metric.html">HistogramMetric</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_max_metric.html">MaxMetric</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metric that simply keeps track of a single value over time.  <a href="class_grappa_1_1_max_metric.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_message.html">Message</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A standard message.  <a href="class_grappa_1_1_message.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_payload_message.html">PayloadMessage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A message with dynamic payload.  <a href="class_grappa_1_1_payload_message.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_message_pool_static.html">MessagePoolStatic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_message_pool.html">MessagePool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_mutex.html">Mutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_pool_allocator.html">PoolAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_pool_allocator_internal.html">PoolAllocatorInternal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_reuse_message.html">ReuseMessage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">message to be used in message pools. adds itself to a list after being sent  <a href="class_grappa_1_1_reuse_message.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_reuse_message_list.html">ReuseMessageList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reuse list of messages.  <a href="class_grappa_1_1_reuse_message_list.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SimpleMetric</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metric that simply keeps track of a single value over time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_string_metric.html">StringMetric</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metric that simply keeps track of a single string value over time.  <a href="class_grappa_1_1_string_metric.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_summarizing_metric.html">SummarizingMetric</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_suspended_delegate.html">SuspendedDelegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_basic_scheduler.html">BasicScheduler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic <a class="el" href="class_grappa_1_1_worker.html" title="Worker/coroutine.">Worker</a> <a class="el" href="class_grappa_1_1_scheduler.html">Scheduler</a> with just a readyQ and periodicQ.  <a href="class_grappa_1_1_basic_scheduler.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_scheduler.html">Scheduler</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_thread_queue.html">ThreadQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue of threads.  <a href="class_grappa_1_1_thread_queue.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_prefetching_thread_queue.html">PrefetchingThreadQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grappa_1_1_worker.html">Worker</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker/coroutine.  <a href="class_grappa_1_1_worker.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#af14b6d972703cb9a89e4160362cf0d98">Timestamp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamps are 64-bit signed integers.  <a href="#af14b6d972703cb9a89e4160362cf0d98"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> { <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9ab78b8d76a351034ab28fe59ac45519a4">Bound</a>, 
<a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9a358a7477b150e82b4099f9a9940ad3be">Unbound</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether tasks are bound to the core they're spawned on, or if they can be load-balanced (via work-stealing).  <a href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> { <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7aafc1cef496d894e61f81646c2f708453a">Blocking</a>, 
<a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7aa52577145b31846dc52aaae2b00e94d82">Async</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether an operation blocks until complete, or returns "immediately".  <a href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#acb42d77875bd5cf444f1f3160ca5db76">FCStatus</a> { <a class="el" href="namespace_grappa.html#acb42d77875bd5cf444f1f3160ca5db76a5e9c9bbc4a634a8c6114e608d0230ecb">SATISFIED</a>, 
<a class="el" href="namespace_grappa.html#acb42d77875bd5cf444f1f3160ca5db76a9ca9d55bbc9595da8a536be54b3360ca">BLOCKED</a>, 
<a class="el" href="namespace_grappa.html#acb42d77875bd5cf444f1f3160ca5db76ad992a7ced6dddc3335d9897ad8edaf75">MATCHED</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin for adding common global data structure functionality, such as mirrored allocation on all cores.  <a href="namespace_grappa.html#acb42d77875bd5cf444f1f3160ca5db76">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___containers.html#gac5a9df86f535f81420219d9dfcab5584">memset</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; base, S value, size_t count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of elements of generic type with a given value.  <a href="group___containers.html#gac5a9df86f535f81420219d9dfcab5584"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___containers.html#gadf1e28a91749a97c58d6b1db21d2d607">memset</a> (T *base, S value, size_t count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-based memset for local arrays to match what is provided for distributed arrays.  <a href="group___containers.html#gadf1e28a91749a97c58d6b1db21d2d607"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___containers.html#ga8b39e2df966b32aea640b93e3c5b502c">memcpy</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; dst, <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; src, size_t nelem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Memcpy over <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a> global arrays.  <a href="group___containers.html#ga8b39e2df966b32aea640b93e3c5b502c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___containers.html#ga203f1b78785e927f8cb1fbfe262de33e">memcpy</a> (T *dst, T *src, size_t nelem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper so we don't have to change the code if we change a Global pointer to a normal pointer (in theory).  <a href="group___containers.html#ga203f1b78785e927f8cb1fbfe262de33e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___containers.html#ga66050c7210e15962b855d514842c3a88">memcpy&lt; void &gt;</a> (void *dst, void *src, size_t nelem)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;GlobalCompletionEvent * GCE = &amp;impl::local_gce, typename T  = void&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___containers.html#ga97ac566b2b1886d9c51123ddd9a2eede">memcpy_async</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; dst, <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; src, size_t nelem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous version of memcpy, spawns only on cores with array elements.  <a href="group___containers.html#ga97ac566b2b1886d9c51123ddd9a2eede"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___containers.html#ga257b0d2c3a3432a0f1f8c6037390e3d2">prefix_sum</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; array, size_t nelem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">not implemented yet  <a href="group___containers.html#ga257b0d2c3a3432a0f1f8c6037390e3d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gab6c76d75bef0d7b03eb1b9b8ded580d8">barrier</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking SPMD barrier (must be called once on all cores to continue)  <a href="group___synchronization.html#gab6c76d75bef0d7b03eb1b9b8ded580d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#ga34aff137286f631648c195112fcfb8ad">call_on_all_cores</a> (F work)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call message (work that cannot block) on all cores, block until ack received from all.  <a href="group___collectives.html#ga34aff137286f631648c195112fcfb8ad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#gac74a2d7ffb5b36ec6833ebfc54c16841">on_all_cores</a> (F work)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a private task on each core, block until all complete.  <a href="group___collectives.html#gac74a2d7ffb5b36ec6833ebfc54c16841"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , T(*)(const T &amp;, const T &amp;) ReduceOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#gaf8f3fd1aa6b179823dde8e88dab682f8">allreduce</a> (T myval)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from SPMD context, reduces values from all cores calling `allreduce` and returns reduced values to everyone.  <a href="group___collectives.html#gaf8f3fd1aa6b179823dde8e88dab682f8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , T(*)(const T &amp;, const T &amp;) ReduceOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#gabd3ee93956b1a6047d45d2e93f2e0b1e">allreduce_inplace</a> (T *array, size_t nelem=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from SPMD context.  <a href="group___collectives.html#gabd3ee93956b1a6047d45d2e93f2e0b1e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , T(*)(const T &amp;, const T &amp;) ReduceOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#gaacc2618bb00fc9fbbf6b154a9258d18a">reduce</a> (const T *global_ptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from a single task (usually user_main), reduces values from all cores onto the calling node.  <a href="group___collectives.html#gaacc2618bb00fc9fbbf6b154a9258d18a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , T(*)(const T &amp;, const T &amp;) ReduceOp&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#gaf13e242540fe6c651385acaf94d42c83">reduce</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; localizable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce over a symmetrically allocated object.  <a href="group___collectives.html#gaf13e242540fe6c651385acaf94d42c83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , T(*)(const T &amp;, const T &amp;) ReduceOp, T(*)(GlobalAddress&lt; P &gt;) Accessor&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#gaed4325271e72af888ce395fba4ca1380">reduce</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; P &gt; localizable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce over a member of a symmetrically allocated object.  <a href="group___collectives.html#gaed4325271e72af888ce395fba4ca1380"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F  = nullptr_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___collectives.html#ga341d2565af8f4d29e434ad30479a8870">sum_all_cores</a> (F func)-&gt; decltype(func())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom reduction from all cores.  <a href="group___collectives.html#ga341d2565af8f4d29e434ad30479a8870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a10cafc5a51b1eefe09225ca90dd79efb">walltime</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Universal" wallclock time (works at least for Mac, MTA, and most Linux)  <a href="#a10cafc5a51b1eefe09225ca90dd79efb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utility.html#gafcbdfaa9de31d679a52eda38a521cec5">typename_of</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string containing name of type.  <a href="group___utility.html#gafcbdfaa9de31d679a52eda38a521cec5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utility.html#ga3d051099836ebef97277941196c527eb">typename_of</a> (const T &amp;unused)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string containing name of type.  <a href="group___utility.html#ga3d051099836ebef97277941196c527eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#ga555f2bf877bea827ace1d7c969b763f9">cores</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">How many cores are there in this job?  <a href="group___communication.html#ga555f2bf877bea827ace1d7c969b763f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#gad7a90083b28f17590bdcb069172f33f6">mycore</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">What's my core ID in this job?  <a href="group___communication.html#gad7a90083b28f17590bdcb069172f33f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#ga267489699cd07db87caa07c9784dbac5">locale_cores</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">How many cores are in my shared memory domain?  <a href="group___communication.html#ga267489699cd07db87caa07c9784dbac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#ga807b9abe099d881ca3b479a1ff95a514">locale_mycore</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">What's my core ID within my shared memory domain?  <a href="group___communication.html#ga807b9abe099d881ca3b479a1ff95a514"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_communicator_8hpp.html#a6ecf8097f2a94b9da0f855a386d4570b">Locale</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#ga530158645b7b2b52a268daedf44d0fd9">locales</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">How many shared memory domains are in this job?  <a href="group___communication.html#ga530158645b7b2b52a268daedf44d0fd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_communicator_8hpp.html#a6ecf8097f2a94b9da0f855a386d4570b">Locale</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#ga25ad3b51e8430df89259e1c65526e2e7">mylocale</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">What's my shared memory domain ID within this job?  <a href="group___communication.html#ga25ad3b51e8430df89259e1c65526e2e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_communicator_8hpp.html#a6ecf8097f2a94b9da0f855a386d4570b">Locale</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#gaebb0c9c0eb25b74767305df3ae81915a">locale_of</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">What shared memory domain does core c belong to?  <a href="group___communication.html#gaebb0c9c0eb25b74767305df3ae81915a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CompletionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gad0f5511c9e55d6d5cd3add33bf00d527">complete</a> (CompletionType *ce)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Match ConditionVariable-style function call.  <a href="group___synchronization.html#gad0f5511c9e55d6d5cd3add33bf00d527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga4ba30941b3c166c8eeeee3d31a438d35">complete</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_completion_event.html">CompletionEvent</a> &gt; ce, int64_t decr=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to work on GlobalAddresses.  <a href="group___synchronization.html#ga4ba30941b3c166c8eeeee3d31a438d35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga10fe6e2ee5bf5a8d8e9f9fd11dfee5cb">enroll</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_completion_event.html">CompletionEvent</a> &gt; ce, int64_t incr=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;TaskMode B = TaskMode::Bound, typename TF  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8">spawn</a> (<a class="el" href="class_grappa_1_1_completion_event.html">CompletionEvent</a> *ce, TF tf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn <a class="el" href="group___tasking.html#gaf80429bfcdf0167257fdc0fcc02842fb" title="Spawn a task visible to this Core only.">Grappa::privateTask</a> and implicitly synchronize with the given <a class="el" href="class_grappa_1_1_completion_event.html" title="Synchronization primitive useful for waking a worker after a number of other things complete...">CompletionEvent</a> (or <a class="el" href="class_grappa_1_1_global_completion_event.html" title="GlobalCompletionEvent (GCE): Synchronization construct for determining when a global phase of asynchr...">GlobalCompletionEvent</a>, though if using <a class="el" href="class_grappa_1_1_global_completion_event.html" title="GlobalCompletionEvent (GCE): Synchronization construct for determining when a global phase of asynchr...">GlobalCompletionEvent</a>, it may be better to use the verison that takes the GCE pointer as a template parameter only).  <a href="group___synchronization.html#gad28a884076dc9b8914e694d245b03bf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9">wait</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> &gt; m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for remote <a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> manipulation.  <a href="group___synchronization.html#ga0e49ee2c2ae50e793e427b0fcfa842f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ConditionVariable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gabcf3b681a173156001dc47e12c081de9">signal</a> (const <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> &gt; m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga37a246c9cb77c17a88a376ce83bbcb93">signal_all</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> &gt; m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: implement.  <a href="group___synchronization.html#ga37a246c9cb77c17a88a376ce83bbcb93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga3d9f04a01527d8bea9b1ceab88418e6f">static_assert</a> (sizeof(<a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a>)==8,&quot;ConditionVariable is not 64 bits for some reason.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> is only one word.  <a href="group___synchronization.html#ga3d9f04a01527d8bea9b1ceab88418e6f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ConditionVariable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga32f0284539cca3dc00915931b86a1cb3">add_waiter</a> (<a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> *cv, <a class="el" href="class_grappa_1_1_worker.html">Worker</a> *w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable (no mutex).  <a href="group___synchronization.html#ga32f0284539cca3dc00915931b86a1cb3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ConditionVariable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga4241b1cbe305caf3ca08d2fea8468edf">wait</a> (<a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> *cv)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ConditionVariable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga6f13ef84c9e8693d675d10428cf6c776">signal</a> (<a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> *cv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake one waiter on a condition variable.  <a href="group___synchronization.html#ga6f13ef84c9e8693d675d10428cf6c776"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ConditionVariable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga7cf72c5ef30262df14f5406d790dc798">broadcast</a> (<a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> *cv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake all waiters on a condition variable.  <a href="group___synchronization.html#ga7cf72c5ef30262df14f5406d790dc798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gaebb483063a1dbb84a282e2bbe7042afa">static_assert</a> (sizeof(<a class="el" href="class_grappa_1_1_counting_semaphore.html">CountingSemaphore</a>)==8,&quot;CountingSemaphore is not 64 bits for some reason.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <a class="el" href="class_grappa_1_1_counting_semaphore.html" title="Counting semaphore. Maximum count is 2^15 - 1.">CountingSemaphore</a> is only one word.  <a href="group___synchronization.html#gaebb483063a1dbb84a282e2bbe7042afa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;TaskMode B = TaskMode::Bound, GlobalCompletionEvent * C = &amp;impl::local_gce, typename F  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___delegates.html#gac3b9a55615b0754717c2b20ef63044c2">spawnRemote</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, F f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizing remote private task spawn.  <a href="group___delegates.html#gac3b9a55615b0754717c2b20ef63044c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_external_count_payload_message.html">Grappa::ExternalCountPayloadMessage</a> <br class="typebreak"/>
<a class="el" href="class_grappa_1_1_payload_message.html">Grappa::PayloadMessage</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga6e66347e169115ff06e527ad77c2e321">__attribute__</a> ((aligned(64)))</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_external_count_payload_message.html">ExternalCountPayloadMessage</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#ac841f71522852e7708be1cc644f3eb2a">send_heap_message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t, void *payload, size_t payload_size, uint64_t *count)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utility.html#ga28fe44710a582b4534c81eef84596476">read_array</a> (<a class="el" href="struct_grappa_1_1_file.html">File</a> &amp;f, <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; array, size_t nelem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file or directory of files into a global array.  <a href="group___utility.html#ga28fe44710a582b4534c81eef84596476"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utility.html#ga2723b0cec7b9cdd83715bc383bbeb310">save_array</a> (<a class="el" href="struct_grappa_1_1_file.html">File</a> &amp;f, bool asDirectory, <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; array, size_t nelem)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utility.html#gaa36ea6df58c48bf54c2fd59547c890e0">write_array_unordered</a> (std::string filename, <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; array, size_t nelem)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utility.html#ga3d61348ea7920b020f10f2ec89cd18d2">read_array_unordered</a> (std::string filename, <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; array, size_t nelem)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga08cc992debd2459c04c2412361cb72f7">fill_remote</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt;&gt; result_addr, const T &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga9cef2af61c52a6bea65625de747ca8b3">readFF</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt;&gt; fe_addr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote version of readFF method. Suspend until <a class="el" href="class_grappa_1_1_full_empty.html" title="Wrapper class to provide full-bit semantics for arbitrary data.">FullEmpty</a> is full, and then return its contents, leaving it full.  <a href="group___synchronization.html#ga9cef2af61c52a6bea65625de747ca8b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga27dbd4448ca94a3d7b58759f4288c6e6">writeXF</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt;&gt; fe_addr, const U &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote, blocking version of writeXF method. Writes data to <a class="el" href="class_grappa_1_1_full_empty.html" title="Wrapper class to provide full-bit semantics for arbitrary data.">FullEmpty</a> no matter what its current state, leaving it full. Existing contents are overwritten.  <a href="group___synchronization.html#ga27dbd4448ca94a3d7b58759f4288c6e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gad306de5c289de2f249e814551a62d85b">writeXF</a> (<a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt; *fe_addr, T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member version of writeXF method.  <a href="group___synchronization.html#gad306de5c289de2f249e814551a62d85b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga63f6c01b0bc1fbb8f3a8b01177257bca">writeEF</a> (<a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt; *fe_addr, T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member version of writeEF method.  <a href="group___synchronization.html#ga63f6c01b0bc1fbb8f3a8b01177257bca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga952c1e020c17e0264d3d738df66f3f8e">writeFF</a> (<a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt; *fe_addr, T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member version of writeFF method.  <a href="group___synchronization.html#ga952c1e020c17e0264d3d738df66f3f8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gacb97e74af74ce0b9b664ea681d8f9b91">readXX</a> (<a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt; *fe_addr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member version of readXX method.  <a href="group___synchronization.html#gacb97e74af74ce0b9b664ea681d8f9b91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga38a19bdec882607fc363f0880fe6b954">readFF</a> (<a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt; *fe_addr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member version of readFF method.  <a href="group___synchronization.html#ga38a19bdec882607fc363f0880fe6b954"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga25fe08f26290a226f10c329e1102a5b6">readFE</a> (<a class="el" href="class_grappa_1_1_full_empty.html">FullEmpty</a>&lt; T &gt; *fe_addr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member version of readFE method.  <a href="group___synchronization.html#ga25fe08f26290a226f10c329e1102a5b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T  = int8_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#af74993efb7bbea33d4e7e79953502cf1">global_alloc</a> (size_t count)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate bytes from the global shared heap.  <a href="#af74993efb7bbea33d4e7e79953502cf1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a0b29dfddf8e0c5d3c912565a0b1db6d0">global_free</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated from global shared heap.  <a href="#a0b29dfddf8e0c5d3c912565a0b1db6d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , Core MASTER_CORE = 0&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a4d7e988484354f73edd1d56c5c07f7e7">symmetric_global_alloc</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a T at the same localizable global address on all cores (must currently round up to a multiple of block_size plus an additional block to ensure there is a valid address range no matter which core allocation starts on).  <a href="#a4d7e988484354f73edd1d56c5c07f7e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;SyncMode S = SyncMode::Blocking, GlobalCompletionEvent * C = &amp;impl::local_gce, int64_t Th = impl::USE_LOOP_THRESHOLD_FLAG, typename F  = nullptr_t, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a1ed4d8834b19ab66a22aebe5b92fd186">forall</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_global_bag.html">GlobalBag</a>&lt; T &gt;&gt; b, F body)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_grappa_1_1_completion_target.html">CompletionTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga07bd1fb10deeb37fdaec5d0494be0d8a">enroll</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> &gt; ce, int64_t decr=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga6537761b39f5595a3d754483061a763c">complete</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> &gt; ce, int64_t decr=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow calling send_completion using the old way (with global address) TODO: replace all instances with gce.send_completion and remove this?  <a href="group___synchronization.html#ga6537761b39f5595a3d754483061a763c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;TaskMode B, GlobalCompletionEvent * C, typename TF  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tasking.html#ga870395edc072b708200abb3d2e58bd04">spawn</a> (TF tf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizing private task spawn.  <a href="group___tasking.html#ga870395edc072b708200abb3d2e58bd04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;GlobalCompletionEvent * C = &amp;impl::local_gce, typename F  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">finish</a> (F f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;SyncMode S = SyncMode::Blocking, GlobalCompletionEvent * C = &amp;impl::local_gce, typename K  = nullptr_t, typename V  = nullptr_t, typename F  = nullptr_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a86e9ff5650d22dfcf9226405071ee337">insert</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_global_hash_map.html">GlobalHashMap</a>&lt; K, V &gt;&gt; self, K key, F on_insert)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;GlobalCompletionEvent * GCE = &amp;impl::local_gce, int64_t Threshold = impl::USE_LOOP_THRESHOLD_FLAG, typename T  = decltype(nullptr), typename V  = decltype(nullptr), typename F  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a1c507e85501aa5a02cee9c2dae4912fe">forall</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_global_hash_map.html">GlobalHashMap</a>&lt; T, V &gt;&gt; self, F visit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graph.html#ga429cc17aac3ac32715a509f8e4e7186b">forall</a> (g,[](G::Vertex &amp;v){})</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed graph data structure, with customizable vertex and edge data.  <a href="group___graph.html#ga429cc17aac3ac32715a509f8e4e7186b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">~Iteration over adjacencies of <br class="typebreak"/>
single <a class="el" href="group___graph.html#ga0a9647d88e73119f363dc1553ee8d2c4">Vertex</a> &amp;v&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graph.html#ga84facbb6116d0fe3c52e84885de417a3">forall&lt; async &gt;</a> (<a class="el" href="group___graph.html#ga6c416928a252552a745cd34526ecbf65">adj</a>(g, v),[&amp;v](Edge &amp;e){LOG(INFO)&lt;&lt; v.id&lt;&lt; &quot; -&gt; &quot;&lt;&lt; e.id;})</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_grappa_1_1_adj_iterator.html">AdjIterator</a>&lt; G &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___graph.html#ga6c416928a252552a745cd34526ecbf65">adj</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; G &gt; g, typename G::Vertex &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over adjacent vertices. Used with <a class="el" href="namespace_grappa.html#a1ed4d8834b19ab66a22aebe5b92fd186">Grappa::forall()</a>.  <a href="group___graph.html#ga6c416928a252552a745cd34526ecbf65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_grappa_1_1_adj_iterator.html">AdjIterator</a>&lt; G &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___graph.html#ga54fb566e36dd360c4c595119840be672">adj</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; G &gt; g, <a class="el" href="class_global_address.html">GlobalAddress</a>&lt; typename G::Vertex &gt; v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_grappa_1_1_adj_iterator.html">AdjIterator</a>&lt; G &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___graph.html#gad77bb4adddd0480478286d854c059aef">adj</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; G &gt; g, VertexID i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graph.html#ga6c5d34aaf9546af9ce313a801e5934c4">OVERLOAD</a> (<a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *C=&amp;impl::local_gce, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel loop over adjacent vertices. Use <a class="el" href="group___graph.html#ga6c416928a252552a745cd34526ecbf65" title="Iterator over adjacent vertices. Used with Grappa::forall().">adj()</a> to construct iterator.  <a href="group___graph.html#ga6c5d34aaf9546af9ce313a801e5934c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graph.html#ga6ab22aa2cf82e7d4a56b4986263df8ac">OVERLOAD</a> (<a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *C, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename G  = nullptr_t, typename F  = nullptr_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___graph.html#ga1ba15c6220aea3dc5b3efbf1fdd795a2">serial_for</a> (<a class="el" href="struct_grappa_1_1_adj_iterator.html">AdjIterator</a>&lt; G &gt; a, F body)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;GlobalCompletionEvent * C = &amp;impl::local_gce, int64_t Threshold = impl::USE_LOOP_THRESHOLD_FLAG, typename V , typename E , typename F  = nullptr_t&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___graph.html#gac20551e77df87ef6621f445a2eb52159">forall</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="struct_grappa_1_1_graph.html">Graph</a>&lt; V, E &gt;&gt; g, F loop_body)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iterator over <a class="el" href="struct_grappa_1_1_graph.html">Graph</a>, specializes based on arguments.  <a href="group___graph.html#gac20551e77df87ef6621f445a2eb52159"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a7256570ad424f9fb6a03b901280f192f">local_load_bintsv4</a> (const char *filename, <a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *local_ptr, <a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *local_end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">reading  <a href="#a7256570ad424f9fb6a03b901280f192f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a427e092a084e1dedae14353d8bb054a1">local_save_bintsv4</a> (const char *filename, <a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *local_ptr, <a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *local_end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function run on each core to save edges stored as int32_t tuples  <a href="#a427e092a084e1dedae14353d8bb054a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#ab66563762ea551cb86f0f4bf199cb4be">local_save_tsv</a> (const char *filename, <a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *local_ptr, <a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *local_end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function run on each core to save edges stored as ASCII tab-delimited pairs  <a href="#ab66563762ea551cb86f0f4bf199cb4be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a74fc633986a2fc14a1df80d3efc79d61">global_heap_init</a> (size_t init_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f">init</a> (int *argc_p, char **argv_p[], int64_t <a class="el" href="_message_base_8hpp.html#af81ea7da6a8dfdf7324108998b6c33b1">size</a>=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a>.  <a href="#af7b60a124d5f39fd448e002fa2a3e11f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a661c56b3ed1f67b0ae3228e67a738380">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a>.  <a href="#a661c56b3ed1f67b0ae3228e67a738380"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga513650f0aa54bcb773e4d661ce46c775">locale_alloc</a> (size_t n=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory in locale shared heap.  <a href="group___memory.html#ga513650f0aa54bcb773e4d661ce46c775"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga61d5d896a65487f41e9a7533288ec660">locale_alloc_aligned</a> (size_t alignment, size_t n=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gab40a94f8698c8ad032dab7cf67cc26cf">locale_new</a> (Args &amp;&amp;...args)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate an object in the locale shared heap, passing arguments to its constructor  <a href="group___memory.html#gab40a94f8698c8ad032dab7cf67cc26cf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga05e445a68ba363b9639c11ffcc9c8373">locale_new</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate an object in the locale shared heap  <a href="group___memory.html#ga05e445a68ba363b9639c11ffcc9c8373"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga43aafa32c14634d7f6f7faf54ed5c1c3">locale_new_array</a> (size_t n=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate an array in the locale shared heap  <a href="group___memory.html#ga43aafa32c14634d7f6f7faf54ed5c1c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gaa4a3a0de4cfe636ab80665337cc8d7b0">locale_free</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory that was allocated from locale shared heap.  <a href="group___memory.html#gaa4a3a0de4cfe636ab80665337cc8d7b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_message.html">Message</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga1b0faf3e8ee3ef69117c14c5d4547396">message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a message allocated on the stack.  <a href="group___communication.html#ga1b0faf3e8ee3ef69117c14c5d4547396"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_payload_message.html">PayloadMessage</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#gab3bb6fb2dcd4b3e39012d2bdbb475267">message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t, void *payload, size_t payload_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_grappa_1_1_message.html" title="A standard message.">Message</a> with payload.  <a href="group___communication.html#gab3bb6fb2dcd4b3e39012d2bdbb475267"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_message.html">Message</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga528d3be2db6c7577613bba8b60bf01d3">send_message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as message, but immediately enqueued to be sent.  <a href="group___communication.html#ga528d3be2db6c7577613bba8b60bf01d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_payload_message.html">PayloadMessage</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga6e65f7faed0d5d92611442f9b46cb3e8">send_message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t, void *payload, size_t payload_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_grappa_1_1_message.html" title="A standard message.">Message</a> with payload, immediately enqueued to be sent.  <a href="group___communication.html#ga6e65f7faed0d5d92611442f9b46cb3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#ae191b21cb664af95b301ff09d77fb738">static_assert</a> (sizeof(<a class="el" href="class_grappa_1_1_mutex.html">Mutex</a>)==8,&quot;Mutex is not 64 bits for some reason.&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> is only one word.  <a href="#ae191b21cb664af95b301ff09d77fb738"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a81c7e266c2e554a1d10e104046d29ac2">lock</a> (<a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> *t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex. Note: wait scheme is unfairly LIFO.  <a href="#a81c7e266c2e554a1d10e104046d29ac2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a2975c4b14aa78038878b3eaa92814c18">trylock</a> (<a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> *t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a mutex. Note: wait scheme is unfairly LIFO.  <a href="#a2975c4b14aa78038878b3eaa92814c18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a0146884e44ffee06c1d1b5707abe05d7">is_unlocked</a> (<a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> *t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a78c4f1011c916cae114063a5d10d8986">unlock</a> (<a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> *t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex. Note: wait scheme is unfairly LIFO.  <a href="#a78c4f1011c916cae114063a5d10d8986"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#aef028f67a25fc24e4af7c1b864505f61">lock</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> &gt; m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: implement.  <a href="#aef028f67a25fc24e4af7c1b864505f61"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a518b56ccfeecd7415bf2964888061023">trylock</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> &gt; m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: implement.  <a href="#a518b56ccfeecd7415bf2964888061023"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a02cf76a15f014e47a2766912301baf61">unlock</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; <a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> &gt; m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: implement.  <a href="#a02cf76a15f014e47a2766912301baf61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga13d0c5158646eeaac0bdcbe406abffe0">default_gce</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;SyncMode S = SyncMode::Blocking, TaskMode B = TaskMode::Bound, GlobalCompletionEvent * GCE = nullptr, int64_t Threshold = impl::USE_LOOP_THRESHOLD_FLAG, typename F  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___loops.html#gabbb9de70beb4444082d136d65c1ad22a">forall_here</a> (int64_t start, int64_t iters, F loop_body)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga52fb488a99dbaa95c3b9d02bd3f6afc2">FORALL_HERE_OVERLOAD</a> (<a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *GCE=nullptr, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga6b706f6f75a9db4ad7c563aaddcab2a4">FORALL_HERE_OVERLOAD</a> (<a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *GCE, <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga3d9ca6ee1346a410f561463173d54d20">FORALL_HERE_OVERLOAD</a> (<a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *GCE, int64_t Threshold, <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#gaabdbef5ebe07bd8e56ffb499e5f83bf0">FORALL_HERE_OVERLOAD</a> (<a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *GCE, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG, <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#gab9fa3386ab8032333b1e9bc2ccd1a54b">FORALL_HERE_OVERLOAD</a> (int64_t Threshold, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *GCE=nullptr, <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga46e720d695f9b662f0f78724838417e0">FORALL_OVERLOAD</a> (<a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *C=&amp;impl::local_gce, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga53f1a7c4703aae6e51f8d1ed6a2ce7fa">FORALL_OVERLOAD</a> (<a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S, <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *C=&amp;impl::local_gce, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga80c2d6b9782cc07da723a36929dbe996">FORALL_OVERLOAD</a> (<a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *C, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG, <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#gac78f2e294c32a361e93bb3d1aec4cb66">FORALL_OVERLOAD</a> (int64_t Threshold, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *C=&amp;impl::local_gce, <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B=TaskMode::Bound, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___loops.html#ga4c51943d29119ebd9c68e580d7d6061f">FORALL_OVERLOAD</a> (<a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">TaskMode</a> B, <a class="el" href="class_grappa_1_1_global_completion_event.html">GlobalCompletionEvent</a> *C, <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">SyncMode</a> S=SyncMode::Blocking, int64_t Threshold=impl::USE_LOOP_THRESHOLD_FLAG)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a>, <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___loops.html#gae0930fb0b5ce9c40ceb40f26e5c3be4a">cores_with_elements</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; base, size_t nelem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return range of cores that have elements for the given linear address range.  <a href="group___loops.html#gae0930fb0b5ce9c40ceb40f26e5c3be4a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;GlobalCompletionEvent * GCE = &amp;impl::local_gce, int64_t Threshold = impl::USE_LOOP_THRESHOLD_FLAG, typename T  = decltype(nullptr), typename F  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___loops.html#gadf2bb62c4a3ba1ae301a59dbec04cda7">on_cores_localized_async</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; base, int64_t nelems, F do_on_core)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run privateTasks on each core that contains elements of the given region of global memory.  <a href="group___loops.html#gadf2bb62c4a3ba1ae301a59dbec04cda7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;TaskMode B = TaskMode::Bound, SyncMode S = SyncMode::Blocking, GlobalCompletionEvent * GCE = &amp;impl::local_gce, int64_t Threshold = impl::USE_LOOP_THRESHOLD_FLAG, typename T  = decltype(nullptr), typename F  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___loops.html#gaaa1df0d48a6d67442b59fc06c16e9c33">forall</a> (<a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt; base, int64_t nelems, F loop_body)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel loop over a global array.  <a href="group___loops.html#gaaa1df0d48a6d67442b59fc06c16e9c33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a51a9bcf9928f2402a6f6f2464f4576c3">forall</a> (A, N,[](int &amp;A_i){if(A_i==0) global_x++;})</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetric object with no special built-in semantics, but several reduction-oriented operations defined.  <a href="#a51a9bcf9928f2402a6f6f2464f4576c3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Semaphore &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga0ea422ccad00a9098e197c9e8c9951db">increment</a> (Semaphore *s, int64_t incr=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Semaphore &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga440cce540d8b12c421c3c48c133c8ab8">decrement</a> (Semaphore *s, int64_t decr=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Semaphore &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#ga80fcd0303be8f096417ed05a4f46cb78">try_decrement</a> (Semaphore *s, int64_t decr=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Semaphore &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___synchronization.html#gaaa921e944ca0d46b3cd144add50d273b">get_value</a> (Semaphore *s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_message.html">Message</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga02e73aabbd5b68bc579361d6373abae1">heap_message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_payload_message.html">PayloadMessage</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga4037ea3ff68f1f75cca95bbc4265d0bd">heap_message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t, void *payload, size_t payload_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_grappa_1_1_message.html" title="A standard message.">Message</a> with payload, allocated on heap.  <a href="group___communication.html#ga4037ea3ff68f1f75cca95bbc4265d0bd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_message.html">Message</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#gae63d3f9cc55e63791365cd2d1811aa29">send_heap_message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as message, but allocated on heap and immediately enqueued to be sent.  <a href="group___communication.html#gae63d3f9cc55e63791365cd2d1811aa29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_payload_message.html">PayloadMessage</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga0b75498515ae24362c7ae4f383d7a7d3">send_heap_message</a> (<a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> dest, T t, void *payload, size_t payload_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_grappa_1_1_message.html" title="A standard message.">Message</a> with payload, allocated on heap and immediately enqueued to be sent.  <a href="group___communication.html#ga0b75498515ae24362c7ae4f383d7a7d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a71018ba89353f75b1a4159b95295b801">invoke</a> (<a class="el" href="class_grappa_1_1_suspended_delegate.html">SuspendedDelegate</a> *c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a695f264ea02b232ac3a716f1cb919567">is_suspended_delegate</a> (<a class="el" href="class_grappa_1_1_worker.html">Worker</a> *w)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tasking.html#gaf80429bfcdf0167257fdc0fcc02842fb">privateTask</a> (TF tf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a task visible to this Core only.  <a href="group___tasking.html#gaf80429bfcdf0167257fdc0fcc02842fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tasking.html#gac76febfd95f119e47f8d2b77ba779669">publicTask</a> (TF tf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a task that may be stolen between cores.  <a href="group___tasking.html#gac76febfd95f119e47f8d2b77ba779669"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tasking.html#ga1de878db1bbbe31c277e36f9ca7bee47">spawn_worker</a> (TF &amp;&amp;tf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>internal</b>  <a href="group___tasking.html#ga1de878db1bbbe31c277e36f9ca7bee47"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;TaskMode B = TaskMode::Bound, typename F  = decltype(nullptr)&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tasking.html#gafa22065aa5dcd33b21d43655c8e27d0a">spawn</a> (F f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">run</a> (FP fp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_worker.html">Worker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___delegates.html#gad7f339c8363a6361960ecbc10d9c7a33">current_worker</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a46d200566e9346ab9bd22e9cb2680cad">barrier_cv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_grappa_1_1_file.html">Grappa::File</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utility.html#gadd65fbbf5adaf182e37952d3d6618567">__attribute__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_grappa_1_1_i_o_descriptor.html">IODescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utility.html#gae02ceb162ea993d1710f3095058229f0">aio_completed_stack</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_grappa_1_1_global_bag.html">Grappa::GlobalBag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___containers.html#gabbe1235a6aa33dbc8145efff8a0c4cd7">GRAPPA_BLOCK_ALIGNED</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___containers.html#gae214c4f2d33524de8eb8bc336d6f6a67">MASTER</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">~Iteration over adjacencies of <br class="typebreak"/>
single&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graph.html#ga0a9647d88e73119f363dc1553ee8d2c4">Vertex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a8147fe9eb5940e2516172fe70e6000ad">tick_rate</a> = 0.0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_grappa_1_1_worker.html">Worker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a3e3907937e4e1aca6bc5019ec38687e1">master_thread</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_grappa.html#a2b263c43983933f3b9185f4786dd725a">total</a> = sum(global_x)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>this core's base pointer </p>
<p>TODO: this should be based on some actual time-related metric so behavior is predictable across machines.</p>
<p>Synchronizing spawns. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a2d83baf92a7c7db4fe0db5a99b72ffc5"></a><!-- doxytag: member="Grappa::Core" ref="a2d83baf92a7c7db4fe0db5a99b72ffc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Core</a> <a class="el" href="namespace_grappa.html#a2d83baf92a7c7db4fe0db5a99b72ffc5">Grappa::Core</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_r_d_m_a_aggregator_8hpp_source.html#l00100">100</a> of file <a class="el" href="_r_d_m_a_aggregator_8hpp_source.html">RDMAAggregator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af14b6d972703cb9a89e4160362cf0d98"></a><!-- doxytag: member="Grappa::Timestamp" ref="af14b6d972703cb9a89e4160362cf0d98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="namespace_grappa.html#af14b6d972703cb9a89e4160362cf0d98">Grappa::Timestamp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timestamps are 64-bit signed integers. </p>
<p>Theoretically this should allow us to do overflow detection, but we ignore it for now. This will still allow many years of operation. </p>

<p>Definition at line <a class="el" href="_timestamp_8hpp_source.html#l00052">52</a> of file <a class="el" href="_timestamp_8hpp_source.html">Timestamp.hpp</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="acb42d77875bd5cf444f1f3160ca5db76"></a><!-- doxytag: member="Grappa::FCStatus" ref="acb42d77875bd5cf444f1f3160ca5db76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_grappa.html#acb42d77875bd5cf444f1f3160ca5db76">Grappa::FCStatus</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mixin for adding common global data structure functionality, such as mirrored allocation on all cores. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acb42d77875bd5cf444f1f3160ca5db76a5e9c9bbc4a634a8c6114e608d0230ecb"></a><!-- doxytag: member="SATISFIED" ref="acb42d77875bd5cf444f1f3160ca5db76a5e9c9bbc4a634a8c6114e608d0230ecb" args="" -->SATISFIED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acb42d77875bd5cf444f1f3160ca5db76a9ca9d55bbc9595da8a536be54b3360ca"></a><!-- doxytag: member="BLOCKED" ref="acb42d77875bd5cf444f1f3160ca5db76a9ca9d55bbc9595da8a536be54b3360ca" args="" -->BLOCKED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acb42d77875bd5cf444f1f3160ca5db76ad992a7ced6dddc3335d9897ad8edaf75"></a><!-- doxytag: member="MATCHED" ref="acb42d77875bd5cf444f1f3160ca5db76ad992a7ced6dddc3335d9897ad8edaf75" args="" -->MATCHED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_flat_combiner_8hpp_source.html#l00092">92</a> of file <a class="el" href="_flat_combiner_8hpp_source.html">FlatCombiner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eb494aa98f6908538488b8d98cdbc7a"></a><!-- doxytag: member="Grappa::SyncMode" ref="a1eb494aa98f6908538488b8d98cdbc7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_grappa.html#a1eb494aa98f6908538488b8d98cdbc7a">Grappa::SyncMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify whether an operation blocks until complete, or returns "immediately". </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1eb494aa98f6908538488b8d98cdbc7aafc1cef496d894e61f81646c2f708453a"></a><!-- doxytag: member="Blocking" ref="a1eb494aa98f6908538488b8d98cdbc7aafc1cef496d894e61f81646c2f708453a" args="" -->Blocking</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1eb494aa98f6908538488b8d98cdbc7aa52577145b31846dc52aaae2b00e94d82"></a><!-- doxytag: member="Async" ref="a1eb494aa98f6908538488b8d98cdbc7aa52577145b31846dc52aaae2b00e94d82" args="" -->Async</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="common_8hpp_source.html#l00106">106</a> of file <a class="el" href="common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6ade1fca200baa13c39fe78703897b9"></a><!-- doxytag: member="Grappa::TaskMode" ref="ac6ade1fca200baa13c39fe78703897b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_grappa.html#ac6ade1fca200baa13c39fe78703897b9">Grappa::TaskMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify whether tasks are bound to the core they're spawned on, or if they can be load-balanced (via work-stealing). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac6ade1fca200baa13c39fe78703897b9ab78b8d76a351034ab28fe59ac45519a4"></a><!-- doxytag: member="Bound" ref="ac6ade1fca200baa13c39fe78703897b9ab78b8d76a351034ab28fe59ac45519a4" args="" -->Bound</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac6ade1fca200baa13c39fe78703897b9a358a7477b150e82b4099f9a9940ad3be"></a><!-- doxytag: member="Unbound" ref="ac6ade1fca200baa13c39fe78703897b9a358a7477b150e82b4099f9a9940ad3be" args="" -->Unbound</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="common_8hpp_source.html#l00103">103</a> of file <a class="el" href="common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a661c56b3ed1f67b0ae3228e67a738380"></a><!-- doxytag: member="Grappa::finalize" ref="a661c56b3ed1f67b0ae3228e67a738380" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespace_grappa.html#a661c56b3ed1f67b0ae3228e67a738380">Grappa::finalize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean up <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a>. </p>
<p>Call in SPMD context after all <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a> code finishes. Running <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a> code after calling <a class="el" href="namespace_grappa.html#a661c56b3ed1f67b0ae3228e67a738380" title="Clean up Grappa.">finalize()</a> is illegal. </p>

<p>Definition at line <a class="el" href="_grappa_8cpp_source.html#l00755">755</a> of file <a class="el" href="_grappa_8cpp_source.html">Grappa.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae60d424e890e6dfc18f880b28b168127"></a><!-- doxytag: member="Grappa::finish" ref="ae60d424e890e6dfc18f880b28b168127" args="(F f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GlobalCompletionEvent * C = &amp;impl::local_gce, typename F  = decltype(nullptr)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#ae60d424e890e6dfc18f880b28b168127">Grappa::finish</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_global_completion_event_8hpp_source.html#l00439">439</a> of file <a class="el" href="_global_completion_event_8hpp_source.html">GlobalCompletionEvent.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ed4d8834b19ab66a22aebe5b92fd186"></a><!-- doxytag: member="Grappa::forall" ref="a1ed4d8834b19ab66a22aebe5b92fd186" args="(GlobalAddress&lt; GlobalBag&lt; T &gt;&gt; b, F body)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SyncMode S = SyncMode::Blocking, GlobalCompletionEvent * C = &amp;impl::local_gce, int64_t Th = impl::USE_LOOP_THRESHOLD_FLAG, typename F  = nullptr_t, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a1ed4d8834b19ab66a22aebe5b92fd186">Grappa::forall</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; GlobalBag&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_global_bag_8hpp_source.html#l00081">81</a> of file <a class="el" href="_global_bag_8hpp_source.html">GlobalBag.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51a9bcf9928f2402a6f6f2464f4576c3"></a><!-- doxytag: member="Grappa::forall" ref="a51a9bcf9928f2402a6f6f2464f4576c3" args="(A, N,[](int &amp;A_i){if(A_i==0) global_x++;})" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_grappa.html#a1ed4d8834b19ab66a22aebe5b92fd186">Grappa::forall</a> </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Symmetric object with no special built-in semantics, but several reduction-oriented operations defined. </p>
<p>Intended to be used as a building block for symmetric objects or when manual management of reductions on symmetric data.</p>
<p>This is closely related to <a class="el" href="class_reducer.html" title="Reducers are a special kind of *symmetric* object that, when read, compute a reduction over all insta...">Reducer</a>, but rather than implicitly performing reduction operations whenever the value is observed, SimpleSymmetric's require one of the helper reducer operations to be applied manually. This flexibility could be useful for doing more than one kind of reduction on the same symmetric object.</p>
<p>Example usage for a global counter: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SimpleSymmetric&lt;int&gt; global_x;</p>
<p>... <a class="el" href="group___tasking.html#ga1fa04570855ffc3d360a5264f950eb24">Grappa::run</a>([]{ GlobalAddress&lt;int&gt; A = /* initialize array A </p>

</div>
</div>
<a class="anchor" id="a1c507e85501aa5a02cee9c2dae4912fe"></a><!-- doxytag: member="Grappa::forall" ref="a1c507e85501aa5a02cee9c2dae4912fe" args="(GlobalAddress&lt; GlobalHashMap&lt; T, V &gt;&gt; self, F visit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GlobalCompletionEvent * GCE = &amp;impl::local_gce, int64_t Threshold = impl::USE_LOOP_THRESHOLD_FLAG, typename T  = decltype(nullptr), typename V  = decltype(nullptr), typename F  = decltype(nullptr)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a1ed4d8834b19ab66a22aebe5b92fd186">Grappa::forall</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; GlobalHashMap&lt; T, V &gt;&gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_global_hash_map_8hpp_source.html#l00297">297</a> of file <a class="el" href="_global_hash_map_8hpp_source.html">GlobalHashMap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af74993efb7bbea33d4e7e79953502cf1"></a><!-- doxytag: member="Grappa::global_alloc" ref="af74993efb7bbea33d4e7e79953502cf1" args="(size_t count)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = int8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt;T&gt; <a class="el" href="namespace_grappa.html#af74993efb7bbea33d4e7e79953502cf1">Grappa::global_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate bytes from the global shared heap. </p>

<p>Definition at line <a class="el" href="_global_allocator_8hpp_source.html#l00151">151</a> of file <a class="el" href="_global_allocator_8hpp_source.html">GlobalAllocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b29dfddf8e0c5d3c912565a0b1db6d0"></a><!-- doxytag: member="Grappa::global_free" ref="a0b29dfddf8e0c5d3c912565a0b1db6d0" args="(GlobalAddress&lt; T &gt; address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a0b29dfddf8e0c5d3c912565a0b1db6d0">Grappa::global_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated from global shared heap. </p>

<p>Definition at line <a class="el" href="_global_allocator_8hpp_source.html#l00158">158</a> of file <a class="el" href="_global_allocator_8hpp_source.html">GlobalAllocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74fc633986a2fc14a1df80d3efc79d61"></a><!-- doxytag: member="Grappa::global_heap_init" ref="a74fc633986a2fc14a1df80d3efc79d61" args="(size_t init_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a74fc633986a2fc14a1df80d3efc79d61">Grappa::global_heap_init</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>init_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_grappa_8cpp_source.html#l00130">130</a> of file <a class="el" href="_grappa_8cpp_source.html">Grappa.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7b60a124d5f39fd448e002fa2a3e11f"></a><!-- doxytag: member="Grappa::init" ref="af7b60a124d5f39fd448e002fa2a3e11f" args="(int *argc_p, char **argv_p[], int64_t size=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f">Grappa::init</a> </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>argc_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv_p</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a>. </p>
<p>Call in SPMD context before running <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a> code. Running <a class="el" href="namespace_grappa.html" title="this core&#39;s base pointer">Grappa</a> code before calling <a class="el" href="namespace_grappa.html#af7b60a124d5f39fd448e002fa2a3e11f" title="Initialize Grappa.">init()</a> is illegal. </p>

<p>Definition at line <a class="el" href="_grappa_8cpp_source.html#l00750">750</a> of file <a class="el" href="_grappa_8cpp_source.html">Grappa.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86e9ff5650d22dfcf9226405071ee337"></a><!-- doxytag: member="Grappa::insert" ref="a86e9ff5650d22dfcf9226405071ee337" args="(GlobalAddress&lt; GlobalHashMap&lt; K, V &gt;&gt; self, K key, F on_insert)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SyncMode S = SyncMode::Blocking, GlobalCompletionEvent * C = &amp;impl::local_gce, typename K  = nullptr_t, typename V  = nullptr_t, typename F  = nullptr_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a86e9ff5650d22dfcf9226405071ee337">Grappa::insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; GlobalHashMap&lt; K, V &gt;&gt;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>on_insert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_global_hash_map_8hpp_source.html#l00277">277</a> of file <a class="el" href="_global_hash_map_8hpp_source.html">GlobalHashMap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71018ba89353f75b1a4159b95295b801"></a><!-- doxytag: member="Grappa::invoke" ref="a71018ba89353f75b1a4159b95295b801" args="(SuspendedDelegate *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a71018ba89353f75b1a4159b95295b801">Grappa::invoke</a> </td>
          <td>(</td>
          <td class="paramtype">SuspendedDelegate *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_suspended_delegate_8hpp_source.html#l00096">96</a> of file <a class="el" href="_suspended_delegate_8hpp_source.html">SuspendedDelegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a695f264ea02b232ac3a716f1cb919567"></a><!-- doxytag: member="Grappa::is_suspended_delegate" ref="a695f264ea02b232ac3a716f1cb919567" args="(Worker *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_grappa.html#a695f264ea02b232ac3a716f1cb919567">Grappa::is_suspended_delegate</a> </td>
          <td>(</td>
          <td class="paramtype">Worker *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_suspended_delegate_8hpp_source.html#l00111">111</a> of file <a class="el" href="_suspended_delegate_8hpp_source.html">SuspendedDelegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0146884e44ffee06c1d1b5707abe05d7"></a><!-- doxytag: member="Grappa::is_unlocked" ref="a0146884e44ffee06c1d1b5707abe05d7" args="(Mutex *t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_grappa.html#a0146884e44ffee06c1d1b5707abe05d7">Grappa::is_unlocked</a> </td>
          <td>(</td>
          <td class="paramtype">Mutex *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_mutex_8hpp_source.html#l00088">88</a> of file <a class="el" href="_mutex_8hpp_source.html">Mutex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7256570ad424f9fb6a03b901280f192f"></a><!-- doxytag: member="Grappa::local_load_bintsv4" ref="a7256570ad424f9fb6a03b901280f192f" args="(const char *filename, Grappa::TupleGraph::Edge *local_ptr, Grappa::TupleGraph::Edge *local_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a7256570ad424f9fb6a03b901280f192f">Grappa::local_load_bintsv4</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>local_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>local_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>reading </p>
<p>helper function run on each core to load edges stored as int32_t tuples in bintsv4 format </p>

<p>Definition at line <a class="el" href="_tuple_graph_8cpp_source.html#l00096">96</a> of file <a class="el" href="_tuple_graph_8cpp_source.html">TupleGraph.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a427e092a084e1dedae14353d8bb054a1"></a><!-- doxytag: member="Grappa::local_save_bintsv4" ref="a427e092a084e1dedae14353d8bb054a1" args="(const char *filename, Grappa::TupleGraph::Edge *local_ptr, Grappa::TupleGraph::Edge *local_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a427e092a084e1dedae14353d8bb054a1">Grappa::local_save_bintsv4</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>local_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>local_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>helper function run on each core to save edges stored as int32_t tuples </p>

<p>Definition at line <a class="el" href="_tuple_graph_8cpp_source.html#l00618">618</a> of file <a class="el" href="_tuple_graph_8cpp_source.html">TupleGraph.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab66563762ea551cb86f0f4bf199cb4be"></a><!-- doxytag: member="Grappa::local_save_tsv" ref="ab66563762ea551cb86f0f4bf199cb4be" args="(const char *filename, Grappa::TupleGraph::Edge *local_ptr, Grappa::TupleGraph::Edge *local_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#ab66563762ea551cb86f0f4bf199cb4be">Grappa::local_save_tsv</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>local_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grappa_1_1_tuple_graph_1_1_edge.html">Grappa::TupleGraph::Edge</a> *&#160;</td>
          <td class="paramname"><em>local_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>helper function run on each core to save edges stored as ASCII tab-delimited pairs </p>

<p>Definition at line <a class="el" href="_tuple_graph_8cpp_source.html#l00660">660</a> of file <a class="el" href="_tuple_graph_8cpp_source.html">TupleGraph.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81c7e266c2e554a1d10e104046d29ac2"></a><!-- doxytag: member="Grappa::lock" ref="a81c7e266c2e554a1d10e104046d29ac2" args="(Mutex *t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a81c7e266c2e554a1d10e104046d29ac2">Grappa::lock</a> </td>
          <td>(</td>
          <td class="paramtype">Mutex *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock a mutex. Note: wait scheme is unfairly LIFO. </p>

<p>Definition at line <a class="el" href="_mutex_8hpp_source.html#l00066">66</a> of file <a class="el" href="_mutex_8hpp_source.html">Mutex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef028f67a25fc24e4af7c1b864505f61"></a><!-- doxytag: member="Grappa::lock" ref="aef028f67a25fc24e4af7c1b864505f61" args="(GlobalAddress&lt; Mutex &gt; m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a81c7e266c2e554a1d10e104046d29ac2">Grappa::lock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; Mutex &gt;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: implement. </p>

<p>Definition at line <a class="el" href="_mutex_8hpp_source.html#l00101">101</a> of file <a class="el" href="_mutex_8hpp_source.html">Mutex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac841f71522852e7708be1cc644f3eb2a"></a><!-- doxytag: member="Grappa::send_heap_message" ref="ac841f71522852e7708be1cc644f3eb2a" args="(Core dest, T t, void *payload, size_t payload_size, uint64_t *count)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grappa_1_1_external_count_payload_message.html">ExternalCountPayloadMessage</a>&lt;T&gt;* <a class="el" href="namespace_grappa.html#ac841f71522852e7708be1cc644f3eb2a">Grappa::send_heap_message</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_communicator_8hpp.html#a3a0af41b6e127e7f96781ce84aa9d40e">Core</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_external_count_payload_message_8hpp_source.html#l00084">84</a> of file <a class="el" href="_external_count_payload_message_8hpp_source.html">ExternalCountPayloadMessage.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae191b21cb664af95b301ff09d77fb738"></a><!-- doxytag: member="Grappa::static_assert" ref="ae191b21cb664af95b301ff09d77fb738" args="(sizeof(Mutex)==8,&quot;Mutex is not 64 bits for some reason.&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___synchronization.html#ga3d9f04a01527d8bea9b1ceab88418e6f">Grappa::static_assert</a> </td>
          <td>(</td>
          <td class="paramtype">sizeof(Mutex)&#160;</td>
          <td class="paramname"> = <code>=8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Mutex is not 64 bits for some reason.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify that <a class="el" href="class_grappa_1_1_mutex.html">Mutex</a> is only one word. </p>

</div>
</div>
<a class="anchor" id="a4d7e988484354f73edd1d56c5c07f7e7"></a><!-- doxytag: member="Grappa::symmetric_global_alloc" ref="a4d7e988484354f73edd1d56c5c07f7e7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Core MASTER_CORE = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt;T&gt; <a class="el" href="namespace_grappa.html#a4d7e988484354f73edd1d56c5c07f7e7">Grappa::symmetric_global_alloc</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate space for a T at the same localizable global address on all cores (must currently round up to a multiple of block_size plus an additional block to ensure there is a valid address range no matter which core allocation starts on). </p>

<p>Definition at line <a class="el" href="_global_allocator_8hpp_source.html#l00166">166</a> of file <a class="el" href="_global_allocator_8hpp_source.html">GlobalAllocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2975c4b14aa78038878b3eaa92814c18"></a><!-- doxytag: member="Grappa::trylock" ref="a2975c4b14aa78038878b3eaa92814c18" args="(Mutex *t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_grappa.html#a2975c4b14aa78038878b3eaa92814c18">Grappa::trylock</a> </td>
          <td>(</td>
          <td class="paramtype">Mutex *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to lock a mutex. Note: wait scheme is unfairly LIFO. </p>

<p>Definition at line <a class="el" href="_mutex_8hpp_source.html#l00077">77</a> of file <a class="el" href="_mutex_8hpp_source.html">Mutex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a518b56ccfeecd7415bf2964888061023"></a><!-- doxytag: member="Grappa::trylock" ref="a518b56ccfeecd7415bf2964888061023" args="(GlobalAddress&lt; Mutex &gt; m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a2975c4b14aa78038878b3eaa92814c18">Grappa::trylock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; Mutex &gt;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: implement. </p>

<p>Definition at line <a class="el" href="_mutex_8hpp_source.html#l00112">112</a> of file <a class="el" href="_mutex_8hpp_source.html">Mutex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78c4f1011c916cae114063a5d10d8986"></a><!-- doxytag: member="Grappa::unlock" ref="a78c4f1011c916cae114063a5d10d8986" args="(Mutex *t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a78c4f1011c916cae114063a5d10d8986">Grappa::unlock</a> </td>
          <td>(</td>
          <td class="paramtype">Mutex *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock a mutex. Note: wait scheme is unfairly LIFO. </p>

<p>Definition at line <a class="el" href="_mutex_8hpp_source.html#l00092">92</a> of file <a class="el" href="_mutex_8hpp_source.html">Mutex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02cf76a15f014e47a2766912301baf61"></a><!-- doxytag: member="Grappa::unlock" ref="a02cf76a15f014e47a2766912301baf61" args="(GlobalAddress&lt; Mutex &gt; m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_grappa.html#a78c4f1011c916cae114063a5d10d8986">Grappa::unlock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_global_address.html">GlobalAddress</a>&lt; Mutex &gt;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: implement. </p>

<p>Definition at line <a class="el" href="_mutex_8hpp_source.html#l00119">119</a> of file <a class="el" href="_mutex_8hpp_source.html">Mutex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10cafc5a51b1eefe09225ca90dd79efb"></a><!-- doxytag: member="Grappa::walltime" ref="a10cafc5a51b1eefe09225ca90dd79efb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_grappa.html#a10cafc5a51b1eefe09225ca90dd79efb">Grappa::walltime</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Universal" wallclock time (works at least for Mac, MTA, and most Linux) </p>

<p>Definition at line <a class="el" href="common_8hpp_source.html#l00110">110</a> of file <a class="el" href="common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a46d200566e9346ab9bd22e9cb2680cad"></a><!-- doxytag: member="Grappa::barrier_cv" ref="a46d200566e9346ab9bd22e9cb2680cad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grappa_1_1_condition_variable.html">ConditionVariable</a> <a class="el" href="namespace_grappa.html#a46d200566e9346ab9bd22e9cb2680cad">Grappa::barrier_cv</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_barrier_8cpp_source.html#l00039">39</a> of file <a class="el" href="_barrier_8cpp_source.html">Barrier.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e3907937e4e1aca6bc5019ec38687e1"></a><!-- doxytag: member="Grappa::master_thread" ref="a3e3907937e4e1aca6bc5019ec38687e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grappa_1_1_worker.html">Worker</a> * <a class="el" href="namespace_grappa.html#a3e3907937e4e1aca6bc5019ec38687e1">Grappa::master_thread</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_grappa_8cpp_source.html#l00110">110</a> of file <a class="el" href="_grappa_8cpp_source.html">Grappa.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8147fe9eb5940e2516172fe70e6000ad"></a><!-- doxytag: member="Grappa::tick_rate" ref="a8147fe9eb5940e2516172fe70e6000ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_grappa.html#a8147fe9eb5940e2516172fe70e6000ad">Grappa::tick_rate</a> = 0.0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_grappa_8cpp_source.html#l00108">108</a> of file <a class="el" href="_grappa_8cpp_source.html">Grappa.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b263c43983933f3b9185f4786dd725a"></a><!-- doxytag: member="Grappa::total" ref="a2b263c43983933f3b9185f4786dd725a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespace_grappa.html#a2b263c43983933f3b9185f4786dd725a">Grappa::total</a> = sum(global_x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_reducer_8hpp_source.html#l00143">143</a> of file <a class="el" href="_reducer_8hpp_source.html">Reducer.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_grappa.html">Grappa</a>      </li>
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->

<!-- <div id="nav-path" class="navpath">
  <ul>
    $navpath
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="$relpath^doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
  </ul>
</div> -->


</body>
</html>
